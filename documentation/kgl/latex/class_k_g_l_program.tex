\hypertarget{class_k_g_l_program}{
\section{KGLProgram Class Reference}
\label{class_k_g_l_program}\index{KGLProgram@{KGLProgram}}
}
Program class.  


{\tt \#include $<$kglprogram.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hyperlink{class_k_g_l_program_e252511a4efad9a198d44a0a69b0f43b}{KGLProgram} ()
\item 
\hyperlink{class_k_g_l_program_a72b7b0ac0efba795712e2e72e067127}{KGLProgram} (const QList$<$ \hyperlink{class_k_g_l_shader}{KGLShader} $\ast$ $>$ \&shaders)
\item 
\hyperlink{class_k_g_l_program_ed56f8e432d8e523deab848515b04bea}{KGLProgram} (const QString \&vertexshaderfile, const QString \&fragmentshaderfile)
\item 
virtual \hyperlink{class_k_g_l_program_2c90a7ed95bc53b2766e556c1ca996cb}{$\sim$KGLProgram} ()
\item 
void \hyperlink{class_k_g_l_program_cb58b41949d3a88b66557f43196dcaba}{addShader} (\hyperlink{class_k_g_l_shader}{KGLShader} $\ast$shader)
\item 
void \hyperlink{class_k_g_l_program_465ecaf07d2116b74bf892d40c7dc17a}{addShaders} (const QList$<$ \hyperlink{class_k_g_l_shader}{KGLShader} $\ast$ $>$ \&shaders)
\item 
virtual bool \hyperlink{class_k_g_l_program_906166edf1fc7332a5ff8d6c1c18469c}{link} ()
\item 
bool \hyperlink{class_k_g_l_program_5c1aeee12f117bcdb9617ef27c223918}{isValid} () const 
\item 
char $\ast$ \hyperlink{class_k_g_l_program_731506a0e8462aa48f576ab4c1d28fc9}{linkLog} () const 
\item 
virtual void \hyperlink{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{bind} () const 
\item 
virtual void \hyperlink{class_k_g_l_program_a52890b41224848903a772049f374dc3}{unbind} () const 
\item 
int \hyperlink{class_k_g_l_program_51a6b83fc54f4364ae013068823a981d}{uniformLocation} (const QString \&name)
\item 
int \hyperlink{class_k_g_l_program_9e38df2dc72639004319fef0c169e3c9}{uniformLocation} (const char $\ast$name)
\item 
int \hyperlink{class_k_g_l_program_16d1cc930ef9585ec503fe935c4b6a9f}{attributeLocation} (const QString \&name)
\item 
int \hyperlink{class_k_g_l_program_237f2223b1ba1c80e90543d0523739c4}{attributeLocation} (const char $\ast$name)
\item 
void \hyperlink{class_k_g_l_program_949c83395eed27219fd984fe33ac9ecf}{invalidateLocations} ()
\item 
bool \hyperlink{class_k_g_l_program_6704e664e129126050b6f5609da1ee61}{setUniform} (const char $\ast$name, float value)
\item 
bool \hyperlink{class_k_g_l_program_a3213a9de09529704183cb61bec910d4}{setUniform} (const char $\ast$name, Eigen::Vector2f value)
\item 
bool \hyperlink{class_k_g_l_program_e971d4c55c57ae853f4d1c8cdd8a22b9}{setUniform} (const char $\ast$name, Eigen::Vector3f value)
\item 
bool \hyperlink{class_k_g_l_program_b5a31ac9ea1f50767144233afaa0a9e3}{setUniform} (const char $\ast$name, Eigen::Vector4f value)
\item 
bool \hyperlink{class_k_g_l_program_4d943d685f583e9a446d44689b6e7b0c}{setUniform} (const char $\ast$name, int value)
\item 
GLuint \hyperlink{class_k_g_l_program_7a9b4ef4da3e149386a50c8d4241b6c6}{glId} () const 
\end{CompactItemize}
\subsection*{Protected Member Functions}
\begin{CompactItemize}
\item 
void \hyperlink{class_k_g_l_program_5c8081f85275e023d6bf034d54bd1721}{init} ()
\end{CompactItemize}
\subsection*{Protected Attributes}
\begin{CompactItemize}
\item 
GLuint \hyperlink{class_k_g_l_program_1200bdd28e580ca66b818dbefee24f22}{mGLId}
\item 
bool \hyperlink{class_k_g_l_program_f228db2a0bcddd2366e1353b25a193dc}{mValid}
\item 
char $\ast$ \hyperlink{class_k_g_l_program_af8102a5a3f4c7bb21f3f0c56c6806a4}{mLinkLog}
\item 
QHash$<$ QString, int $>$ $\ast$ \hyperlink{class_k_g_l_program_b6b870ec76b667369f457cc980e9016c}{mUniformLocations}
\item 
QHash$<$ QString, int $>$ $\ast$ \hyperlink{class_k_g_l_program_7ebfd6e8476719c40d24108a043d7bd1}{mAttributeLocations}
\end{CompactItemize}


\subsection{Detailed Description}
Program class. 

Program is a GPU-executed program that is ready to be used for manipulating geometry and colors. Program can encapsulate vertex and fragment shaders or just one of them. If only either vertex or fragment shader is used, then traditional fixed-function pipeline is used for the other stage.\hypertarget{class_k_g_l_program_creating}{}\subsection{Creating Program objects}\label{class_k_g_l_program_creating}
The easiest way to create usable Program object is to pass filenames of the vertex- and fragment shader to the Program constructor. This automatically creates temporary Shader objects and then combines them into a Program: 

\begin{Code}\begin{verbatim} Program* prog = new Program("myshader.vert", "myshader.frag");
 if (!prog->isValid()) {
     // Error: program failed to load
 }
\end{verbatim}
\end{Code}



It is also possible to add more than one fragment or vertex shader (e.g. you can have some common functions in one shader and the main() function in other) or specify only vertex or only fragment shader. In this case you will have to first create the Shader objects yourself and then add them to a program: 

\begin{Code}\begin{verbatim} // Create Shader objects
 VertexShader vertexShader("myshader.vert");
 FragmentShader fragmentShader("myshader.frag");
 // common.frag could contain common functions shared by different shaders
 FragmentShader commonShader("common.frag");
 // Make sure all shaders were successfully loaded
 if (!vertexShader.isValid() || !fragmentShader.isValid() || !commonShader.isValid()) {
     // handle the error here
     return;
 }

 // Create Program object
 Program* prog = new Program();
 // Add shader objects to program
 prog->addShader(&vertexShader);
 prog->addShader(&fragmentShader);
 prog->addShader(&commonShader);
 // Finally link them together
 prog->link();
 // And make sure everything succeeded
 if (!prog->isValid()) {
     // handle the error
 }
\end{verbatim}
\end{Code}

\hypertarget{class_k_g_l_program_binding}{}\subsection{Binding}\label{class_k_g_l_program_binding}
To use the program, you need to first \hyperlink{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{bind()} it, then render your geometry and finally \hyperlink{class_k_g_l_program_a52890b41224848903a772049f374dc3}{unbind()} it. Note that it's more convenient to use the Mesh class which takes care of the binding and unbinding automatically. 

\begin{Code}\begin{verbatim} prog->bind();
 // Everything rendered now will use the bound program
 renderObjects();
 // Finally unbind the program
 prog->unbind();
\end{verbatim}
\end{Code}

\hypertarget{class_k_g_l_program_uniforms}{}\subsection{Uniform variables}\label{class_k_g_l_program_uniforms}
For communication between GPU Program and your main application, uniform variables can be used. They can be written from your main program and read in shader code. Note that modifying values of uniform variables may be expensive, thus you should do it only when really necessary. 

\begin{Code}\begin{verbatim} // The program has to be bound before setUniform() can be used
 prog->bind();
 // Set variable "objectScale" to 2.0f
 prog->setUniform("objectScale", 2.0f);
 // Unbind the program
 prog->unbind();
\end{verbatim}
\end{Code}



The corresponding section in the shader code would look like this: 

\begin{Code}\begin{verbatim} uniform float objectScale;
 // objectScale can now be used as any other variable
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]Shader, Mesh \end{Desc}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_k_g_l_program_e252511a4efad9a198d44a0a69b0f43b}{
\index{KGLProgram@{KGLProgram}!KGLProgram@{KGLProgram}}
\index{KGLProgram@{KGLProgram}!KGLProgram@{KGLProgram}}
\subsubsection[{KGLProgram}]{\setlength{\rightskip}{0pt plus 5cm}KGLProgram::KGLProgram ()}}
\label{class_k_g_l_program_e252511a4efad9a198d44a0a69b0f43b}


Creates empty Program. You will need to add some shaders and link the program before you can use it. \hypertarget{class_k_g_l_program_a72b7b0ac0efba795712e2e72e067127}{
\index{KGLProgram@{KGLProgram}!KGLProgram@{KGLProgram}}
\index{KGLProgram@{KGLProgram}!KGLProgram@{KGLProgram}}
\subsubsection[{KGLProgram}]{\setlength{\rightskip}{0pt plus 5cm}KGLProgram::KGLProgram (const QList$<$ {\bf KGLShader} $\ast$ $>$ \& {\em shaders})}}
\label{class_k_g_l_program_a72b7b0ac0efba795712e2e72e067127}


Creates Program, adds given list of shaders and links the program. If linking succeeded, the program is ready to be used. \hypertarget{class_k_g_l_program_ed56f8e432d8e523deab848515b04bea}{
\index{KGLProgram@{KGLProgram}!KGLProgram@{KGLProgram}}
\index{KGLProgram@{KGLProgram}!KGLProgram@{KGLProgram}}
\subsubsection[{KGLProgram}]{\setlength{\rightskip}{0pt plus 5cm}KGLProgram::KGLProgram (const QString \& {\em vertexshaderfile}, \/  const QString \& {\em fragmentshaderfile})}}
\label{class_k_g_l_program_ed56f8e432d8e523deab848515b04bea}


Loads vertex and fragment shaders from given files, adds them and links the program. If everything succeeded, then the program is ready to be used. \hypertarget{class_k_g_l_program_2c90a7ed95bc53b2766e556c1ca996cb}{
\index{KGLProgram@{KGLProgram}!$\sim$KGLProgram@{$\sim$KGLProgram}}
\index{$\sim$KGLProgram@{$\sim$KGLProgram}!KGLProgram@{KGLProgram}}
\subsubsection[{$\sim$KGLProgram}]{\setlength{\rightskip}{0pt plus 5cm}KGLProgram::$\sim$KGLProgram ()\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{class_k_g_l_program_2c90a7ed95bc53b2766e556c1ca996cb}


Deletes this library and frees all resources. 

\subsection{Member Function Documentation}
\hypertarget{class_k_g_l_program_cb58b41949d3a88b66557f43196dcaba}{
\index{KGLProgram@{KGLProgram}!addShader@{addShader}}
\index{addShader@{addShader}!KGLProgram@{KGLProgram}}
\subsubsection[{addShader}]{\setlength{\rightskip}{0pt plus 5cm}void KGLProgram::addShader ({\bf KGLShader} $\ast$ {\em shader})}}
\label{class_k_g_l_program_cb58b41949d3a88b66557f43196dcaba}


Adds given shader to this library. \hypertarget{class_k_g_l_program_465ecaf07d2116b74bf892d40c7dc17a}{
\index{KGLProgram@{KGLProgram}!addShaders@{addShaders}}
\index{addShaders@{addShaders}!KGLProgram@{KGLProgram}}
\subsubsection[{addShaders}]{\setlength{\rightskip}{0pt plus 5cm}void KGLProgram::addShaders (const QList$<$ {\bf KGLShader} $\ast$ $>$ \& {\em shaders})}}
\label{class_k_g_l_program_465ecaf07d2116b74bf892d40c7dc17a}


Adds all shaders in the given list to this library. \hypertarget{class_k_g_l_program_237f2223b1ba1c80e90543d0523739c4}{
\index{KGLProgram@{KGLProgram}!attributeLocation@{attributeLocation}}
\index{attributeLocation@{attributeLocation}!KGLProgram@{KGLProgram}}
\subsubsection[{attributeLocation}]{\setlength{\rightskip}{0pt plus 5cm}int KGLProgram::attributeLocation (const char $\ast$ {\em name})}}
\label{class_k_g_l_program_237f2223b1ba1c80e90543d0523739c4}


\hypertarget{class_k_g_l_program_16d1cc930ef9585ec503fe935c4b6a9f}{
\index{KGLProgram@{KGLProgram}!attributeLocation@{attributeLocation}}
\index{attributeLocation@{attributeLocation}!KGLProgram@{KGLProgram}}
\subsubsection[{attributeLocation}]{\setlength{\rightskip}{0pt plus 5cm}int KGLProgram::attributeLocation (const QString \& {\em name})}}
\label{class_k_g_l_program_16d1cc930ef9585ec503fe935c4b6a9f}


\hypertarget{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{
\index{KGLProgram@{KGLProgram}!bind@{bind}}
\index{bind@{bind}!KGLProgram@{KGLProgram}}
\subsubsection[{bind}]{\setlength{\rightskip}{0pt plus 5cm}void KGLProgram::bind () const\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}


Binds the program so that it will be used for anything that is rendered after the \hyperlink{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{bind()} call.

\begin{Desc}
\item[See also:]\hyperlink{class_k_g_l_program_a52890b41224848903a772049f374dc3}{unbind()} \end{Desc}
\hypertarget{class_k_g_l_program_7a9b4ef4da3e149386a50c8d4241b6c6}{
\index{KGLProgram@{KGLProgram}!glId@{glId}}
\index{glId@{glId}!KGLProgram@{KGLProgram}}
\subsubsection[{glId}]{\setlength{\rightskip}{0pt plus 5cm}GLuint KGLProgram::glId () const\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{class_k_g_l_program_7a9b4ef4da3e149386a50c8d4241b6c6}


\begin{Desc}
\item[Returns:]OpenGL id (aka handle) of this library. \end{Desc}
\hypertarget{class_k_g_l_program_5c8081f85275e023d6bf034d54bd1721}{
\index{KGLProgram@{KGLProgram}!init@{init}}
\index{init@{init}!KGLProgram@{KGLProgram}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void KGLProgram::init ()\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{class_k_g_l_program_5c8081f85275e023d6bf034d54bd1721}


\hypertarget{class_k_g_l_program_949c83395eed27219fd984fe33ac9ecf}{
\index{KGLProgram@{KGLProgram}!invalidateLocations@{invalidateLocations}}
\index{invalidateLocations@{invalidateLocations}!KGLProgram@{KGLProgram}}
\subsubsection[{invalidateLocations}]{\setlength{\rightskip}{0pt plus 5cm}void KGLProgram::invalidateLocations ()}}
\label{class_k_g_l_program_949c83395eed27219fd984fe33ac9ecf}


\hypertarget{class_k_g_l_program_5c1aeee12f117bcdb9617ef27c223918}{
\index{KGLProgram@{KGLProgram}!isValid@{isValid}}
\index{isValid@{isValid}!KGLProgram@{KGLProgram}}
\subsubsection[{isValid}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::isValid () const\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{class_k_g_l_program_5c1aeee12f117bcdb9617ef27c223918}


Returns true if this library can be used for rendering, false otherwise.

Invalid programs can be result of syntax errors in the shader code. Program which hasn't been linked yet is also invalid.

\begin{Desc}
\item[See also:]\hyperlink{class_k_g_l_program_906166edf1fc7332a5ff8d6c1c18469c}{link()}, \hyperlink{class_k_g_l_program_731506a0e8462aa48f576ab4c1d28fc9}{linkLog()} \end{Desc}
\hypertarget{class_k_g_l_program_906166edf1fc7332a5ff8d6c1c18469c}{
\index{KGLProgram@{KGLProgram}!link@{link}}
\index{link@{link}!KGLProgram@{KGLProgram}}
\subsubsection[{link}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::link ()\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{class_k_g_l_program_906166edf1fc7332a5ff8d6c1c18469c}


Tries to link the shader. If it succeeds, then the program is ready to be used. If there are errors, they should be visible in the \hyperlink{class_k_g_l_program_731506a0e8462aa48f576ab4c1d28fc9}{linkLog}. \begin{Desc}
\item[Returns:]whether linking succeeded. \end{Desc}
\hypertarget{class_k_g_l_program_731506a0e8462aa48f576ab4c1d28fc9}{
\index{KGLProgram@{KGLProgram}!linkLog@{linkLog}}
\index{linkLog@{linkLog}!KGLProgram@{KGLProgram}}
\subsubsection[{linkLog}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ KGLProgram::linkLog () const\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{class_k_g_l_program_731506a0e8462aa48f576ab4c1d28fc9}


\begin{Desc}
\item[Returns:]Link log of the program or null if there was none or the program hasn't been linked yet. Note that Program keeps ownership of the returned string, so you mustn't delete it. TODO: maybe return QString? \end{Desc}
\hypertarget{class_k_g_l_program_4d943d685f583e9a446d44689b6e7b0c}{
\index{KGLProgram@{KGLProgram}!setUniform@{setUniform}}
\index{setUniform@{setUniform}!KGLProgram@{KGLProgram}}
\subsubsection[{setUniform}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::setUniform (const char $\ast$ {\em name}, \/  int {\em value})}}
\label{class_k_g_l_program_4d943d685f583e9a446d44689b6e7b0c}


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \hypertarget{class_k_g_l_program_b5a31ac9ea1f50767144233afaa0a9e3}{
\index{KGLProgram@{KGLProgram}!setUniform@{setUniform}}
\index{setUniform@{setUniform}!KGLProgram@{KGLProgram}}
\subsubsection[{setUniform}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::setUniform (const char $\ast$ {\em name}, \/  Eigen::Vector4f {\em value})}}
\label{class_k_g_l_program_b5a31ac9ea1f50767144233afaa0a9e3}


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \hypertarget{class_k_g_l_program_e971d4c55c57ae853f4d1c8cdd8a22b9}{
\index{KGLProgram@{KGLProgram}!setUniform@{setUniform}}
\index{setUniform@{setUniform}!KGLProgram@{KGLProgram}}
\subsubsection[{setUniform}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::setUniform (const char $\ast$ {\em name}, \/  Eigen::Vector3f {\em value})}}
\label{class_k_g_l_program_e971d4c55c57ae853f4d1c8cdd8a22b9}


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \hypertarget{class_k_g_l_program_a3213a9de09529704183cb61bec910d4}{
\index{KGLProgram@{KGLProgram}!setUniform@{setUniform}}
\index{setUniform@{setUniform}!KGLProgram@{KGLProgram}}
\subsubsection[{setUniform}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::setUniform (const char $\ast$ {\em name}, \/  Eigen::Vector2f {\em value})}}
\label{class_k_g_l_program_a3213a9de09529704183cb61bec910d4}


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \hypertarget{class_k_g_l_program_6704e664e129126050b6f5609da1ee61}{
\index{KGLProgram@{KGLProgram}!setUniform@{setUniform}}
\index{setUniform@{setUniform}!KGLProgram@{KGLProgram}}
\subsubsection[{setUniform}]{\setlength{\rightskip}{0pt plus 5cm}bool KGLProgram::setUniform (const char $\ast$ {\em name}, \/  float {\em value})}}
\label{class_k_g_l_program_6704e664e129126050b6f5609da1ee61}


Sets the uniform with the given name to the given value and returns true. If there is no uniform with such name then false is returned.

Note that the program has to be bound before this method can be used.

\begin{Desc}
\item[See also:]\hyperlink{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{bind()} \end{Desc}
\hypertarget{class_k_g_l_program_a52890b41224848903a772049f374dc3}{
\index{KGLProgram@{KGLProgram}!unbind@{unbind}}
\index{unbind@{unbind}!KGLProgram@{KGLProgram}}
\subsubsection[{unbind}]{\setlength{\rightskip}{0pt plus 5cm}void KGLProgram::unbind () const\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{class_k_g_l_program_a52890b41224848903a772049f374dc3}


Unbind the program. Anything rendered after \hyperlink{class_k_g_l_program_a52890b41224848903a772049f374dc3}{unbind()} call will be rendered using the fixed-function pipeline. Note that if you want to change the currently used program, you needn't call \hyperlink{class_k_g_l_program_a52890b41224848903a772049f374dc3}{unbind()} before \hyperlink{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{bind()}ing the next program.

\begin{Desc}
\item[See also:]\hyperlink{class_k_g_l_program_48756f0c04a768d2fef06d7ac3d29207}{bind()} \end{Desc}
\hypertarget{class_k_g_l_program_9e38df2dc72639004319fef0c169e3c9}{
\index{KGLProgram@{KGLProgram}!uniformLocation@{uniformLocation}}
\index{uniformLocation@{uniformLocation}!KGLProgram@{KGLProgram}}
\subsubsection[{uniformLocation}]{\setlength{\rightskip}{0pt plus 5cm}int KGLProgram::uniformLocation (const char $\ast$ {\em name})}}
\label{class_k_g_l_program_9e38df2dc72639004319fef0c169e3c9}


\hypertarget{class_k_g_l_program_51a6b83fc54f4364ae013068823a981d}{
\index{KGLProgram@{KGLProgram}!uniformLocation@{uniformLocation}}
\index{uniformLocation@{uniformLocation}!KGLProgram@{KGLProgram}}
\subsubsection[{uniformLocation}]{\setlength{\rightskip}{0pt plus 5cm}int KGLProgram::uniformLocation (const QString \& {\em name})}}
\label{class_k_g_l_program_51a6b83fc54f4364ae013068823a981d}




\subsection{Member Data Documentation}
\hypertarget{class_k_g_l_program_7ebfd6e8476719c40d24108a043d7bd1}{
\index{KGLProgram@{KGLProgram}!mAttributeLocations@{mAttributeLocations}}
\index{mAttributeLocations@{mAttributeLocations}!KGLProgram@{KGLProgram}}
\subsubsection[{mAttributeLocations}]{\setlength{\rightskip}{0pt plus 5cm}QHash$<$QString, int$>$$\ast$ {\bf KGLProgram::mAttributeLocations}\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{class_k_g_l_program_7ebfd6e8476719c40d24108a043d7bd1}


\hypertarget{class_k_g_l_program_1200bdd28e580ca66b818dbefee24f22}{
\index{KGLProgram@{KGLProgram}!mGLId@{mGLId}}
\index{mGLId@{mGLId}!KGLProgram@{KGLProgram}}
\subsubsection[{mGLId}]{\setlength{\rightskip}{0pt plus 5cm}GLuint {\bf KGLProgram::mGLId}\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{class_k_g_l_program_1200bdd28e580ca66b818dbefee24f22}


\hypertarget{class_k_g_l_program_af8102a5a3f4c7bb21f3f0c56c6806a4}{
\index{KGLProgram@{KGLProgram}!mLinkLog@{mLinkLog}}
\index{mLinkLog@{mLinkLog}!KGLProgram@{KGLProgram}}
\subsubsection[{mLinkLog}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ {\bf KGLProgram::mLinkLog}\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{class_k_g_l_program_af8102a5a3f4c7bb21f3f0c56c6806a4}


\hypertarget{class_k_g_l_program_b6b870ec76b667369f457cc980e9016c}{
\index{KGLProgram@{KGLProgram}!mUniformLocations@{mUniformLocations}}
\index{mUniformLocations@{mUniformLocations}!KGLProgram@{KGLProgram}}
\subsubsection[{mUniformLocations}]{\setlength{\rightskip}{0pt plus 5cm}QHash$<$QString, int$>$$\ast$ {\bf KGLProgram::mUniformLocations}\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{class_k_g_l_program_b6b870ec76b667369f457cc980e9016c}


\hypertarget{class_k_g_l_program_f228db2a0bcddd2366e1353b25a193dc}{
\index{KGLProgram@{KGLProgram}!mValid@{mValid}}
\index{mValid@{mValid}!KGLProgram@{KGLProgram}}
\subsubsection[{mValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf KGLProgram::mValid}\hspace{0.3cm}{\tt  \mbox{[}protected\mbox{]}}}}
\label{class_k_g_l_program_f228db2a0bcddd2366e1353b25a193dc}




The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
/home/sacha/programmation/gluon/kgl/\hyperlink{kglprogram_8h}{kglprogram.h}\item 
/home/sacha/programmation/gluon/kgl/\hyperlink{kglprogram_8cpp}{kglprogram.cpp}\end{CompactItemize}
